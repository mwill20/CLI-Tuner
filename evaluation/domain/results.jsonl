{"instruction": "find all the swap files (files ending with ~) in the current folder and delete them", "reference_output": "find . -name \"*~\" -exec rm {} \\;", "predicted_output": "find . -name \"*~\" -exec rm {} \\;", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "display the three smallest files by size in a folder.", "reference_output": "find /etc/ -type f -exec ls -s {} + | sort -n | head -3", "predicted_output": "find . -type f -exec ls -l {} \\; | sort -n | head -3", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Split all files in the directory tree \"/dev/shm/split/\" into files of at most 1000 lines each and use the filename as the prefix", "reference_output": "find /dev/shm/split/ -type f -exec split -l 1000 {} {} \\;", "predicted_output": "find /dev/shm/split/ -type f -exec split -l 1000 {} {}.split \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Search the current directory tree for files whose names begin with 'my'", "reference_output": "find . -name 'my*'", "predicted_output": "find . -name my*", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Counts lines in each *.cpp, *.c, *.h file.", "reference_output": "wc -l `find . -type f \\ -print`", "predicted_output": "find . -name \"*.cpp\" -o -name \"*.c\" -o -name \"*.h\" | xargs wc -l", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "display all the jpg images in current folder", "reference_output": "find . -type f -iregex '.*\\.jpe?g'", "predicted_output": "find . -name \"*.jpg\" -print", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Archive \"foo/bar/baz.c\" to \"remote:/tmp/\" preserving the relative path of \"foo/bar/baz.c\"", "reference_output": "rsync -avR foo/bar/baz.c remote:/tmp/", "predicted_output": "rsync -avz --progress foo/bar/baz.c remote:/tmp/", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Number each line in \"/etc/passwd\" as right-justified zero padded to a width of 9", "reference_output": "nl -nrz -w9  /etc/passwd", "predicted_output": "cat /etc/passwd | nl -w 9 -n right -p", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "file1.txt and file2.txt both contain a name and a number on each line. For each name whose corresponding number does not match in both files, display the \"Age of ... is different\" message.", "reference_output": "join file{1,2}.txt | awk '$2 != $3 { print \"Age of \" $1 \" is different\" }'", "predicted_output": "join -t, -1 1 -2 1 file1.txt file2.txt | awk -F, '$2 != $4 {print \"Age of \" $1 \" is different\"}'", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all files/directories under current directory and append a null character at the end of each path", "reference_output": "find -print0", "predicted_output": "find . -print0", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all php files in current directory and delete text matching the regex '<?php /\\*\\*/ eval(base64_decode(\"aWY.*?>' in those files", "reference_output": "find ./ -name \"*.php\" -type f | xargs sed -i 's#<?php /\\*\\*/ eval(base64_decode(\"aWY.*?>##g'  2>&1", "predicted_output": "find . -name \"*.php\" -exec sed -i 's/<?php /\\*\\*/ eval(base64_decode(\"aWY.*?>//g' {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "find all the empty directories in the current folder", "reference_output": "find . -type d -empty", "predicted_output": "find . -type d -empty", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "Search the current directory tree for hidden files skipping .htaccess", "reference_output": "find . -type f \\( -iname \".*\" ! -iname \".htaccess\" \\)", "predicted_output": "find . -name \".htaccess\" -prune -o -name \".*\" -print", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Search for files/directories named 'fileName.txt' under current directory tree without traversing into './ignored_directory'", "reference_output": "find . -path ./ignored_directory -prune -o -name fileName.txt -print", "predicted_output": "find . -path ./ignored_directory -prune -o -name fileName.txt -print", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "Read a line from standard input into variable \"response\" without backslash escapes using the prompt \"About to delete all items from history that match \\\"$param\\\". Are you sure? [y/N] \"", "reference_output": "read -r -p \"About to delete all items from history that match \\\"$param\\\". Are you sure? [y/N] \" response", "predicted_output": "read -r -p \"About to delete all items from history that match \\\"$param\\\". Are you sure? [y/N] \" response", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "Archive \"src\" to \"dst\" updating files existing in \"dst\"", "reference_output": "rsync -a -v src dst", "predicted_output": "rsync -av --delete src/ dst/", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Delete files with inode number specified by [inode-number] under current directory", "reference_output": "find . -inum [inode-number] -exec rm -i {} \\;", "predicted_output": "find . -inum [inode-number] -exec rm {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all regular files with permissions 777 under and below /home/user/demo/", "reference_output": "find /home/user/demo -type f -perm 777 -print", "predicted_output": "find /home/user/demo/ -type f -perm 777", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Locate files with user permissions rwx owned by my_user", "reference_output": "find . -user my_user -perm -u+rwx", "predicted_output": "find / -user my_user -perm 700", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "find all the php files in the current folder", "reference_output": "find . -name \u201c*.[php|PHP]\u201d -print", "predicted_output": "find . -name \"*.php\"", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Make directories \"bravo_dir\" and \"alpha_dir\"", "reference_output": "mkdir bravo_dir alpha_dir", "predicted_output": "mkdir bravo_dir alpha_dir", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "display all the files in the current folder which have been modified in one hour ago", "reference_output": "find .  -newermt \"1 hour ago\"", "predicted_output": "find . -mmin -60", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Execute /usr/bin/find with $* arguments", "reference_output": "/usr/bin/find $*", "predicted_output": "exec /usr/bin/find $*", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Open all .c files in the current directory tree in the vim editor", "reference_output": "find . -name \"*.c\" -print | vim -", "predicted_output": "find . -name \"*.c\" -exec vim {} + \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "find  files which  full path name is /tmp/foo/bar under foo directory and print", "reference_output": "find foo -path /tmp/foo/bar -print", "predicted_output": "find /tmp/foo/bar -name bar", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Calculate the SHA1 sum for the contents of the path/to/folder directory tree, including permissions", "reference_output": "find path/to/folder -type f -print0  | sort -z | xargs -0 sha1sum; find path/to/folder \\ -print0 | sort -z | xargs -0 stat -c '%n %a' | sha1sum", "predicted_output": "find path/to/folder -type f -print0 | xargs -0 sha1sum | sha1sum", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Remove all .tmp files in and below /tmp", "reference_output": "find /tmp -name \"*.tmp\" | xargs rm", "predicted_output": "find /tmp -name \"*.tmp\" -exec rm {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Set permissions to 2770 for all directories in the current directory tree", "reference_output": "find . -type d -exec chmod 2770 {} +", "predicted_output": "find . -type d -exec chmod 2770 {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "To descend at most one levels of directories below the command line arguments pass the -maxdepth 1 option. This will avoid deleting nested directories:", "reference_output": "find .  -maxdepth 1 -type d -iname \".[^.]*\" -print0 | xargs -I {} -0 rm -rvf \"{}\"", "predicted_output": "find \"$@\" -maxdepth 1 -type d -exec rm -rf {} +", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all files/directories under current directory and sort them", "reference_output": "find | sort", "predicted_output": "find . | sort", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Split \"list.txt\" into files with at most 600 lines each", "reference_output": "split -l 600 list.txt", "predicted_output": "split -l 600 list.txt", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "change the permission of all the normal/regular files to 644 in the current folder", "reference_output": "find -type f -exec chmod 644 {} \\;", "predicted_output": "find . -type f -exec chmod 644 {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find files/directories that belong to user 'ian' under '/tmp' directory tree", "reference_output": "find /tmp -user ian", "predicted_output": "find /tmp -user ian", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "Change the permission to 0644 for all files under current directory", "reference_output": "find . -type f -exec chmod 0644 {} \\;", "predicted_output": "find . -type f -exec chmod 0644 {} \\;", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "find all the files in the home folder which have been modified in the last 24 hours", "reference_output": "find $HOME -mtime -1", "predicted_output": "find ~ -mtime -1", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "find all the java script files in a folder and save the list to a file", "reference_output": "find src/js -type f -name \"*.js\" > list.txt", "predicted_output": "find . -name \"*.js\" -print > jsfiles.txt", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "insert \"e\" when it's pressed", "reference_output": "bind '\"e\":self-insert'", "predicted_output": "stty -echo", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Print number of lines that equal in files '/home/xyz/a.csv1' and '/home/abc/tempfile'", "reference_output": "comm -12 <(sort -u /home/xyz/a.csv1) <(sort -u /home/abc/tempfile) | wc -l", "predicted_output": "comm -12 /home/xyz/a.csv1 /home/abc/tempfile | wc -l", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Delete all .svn files/directories under current directory", "reference_output": "find . -name .svn |xargs rm -rf", "predicted_output": "find . -name .svn -type d -exec rm -rf {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Prints total count of lines of all *.php files in a current folder and subfolders.", "reference_output": "find . -name '*.php' -type f -exec cat -- {} + | wc -l", "predicted_output": "find . -name \"*.php\" | xargs wc -l | tail -1", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find files that were modified less than 7 days ago and archive them", "reference_output": "find . -type f -mtime -7 | xargs tar -cvf `date '+%d%m%Y'_archive.tar`", "predicted_output": "find /path/to/directory -mtime -7 -print0 | xargs -0 tar -cvf archive.tar", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Creates file by template 'aws-sync-XXXXX' in a current folder and stores file name in a 'dir' variable.", "reference_output": "dir=\"$\"", "predicted_output": "dir=$(mktemp aws-sync-XXXXX)", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Remove duplicate lines in \"file_name\" and print the output on stdout", "reference_output": "awk '{print}' file_name | sort -t$'\\t' -k2,2 | uniq --skip-fields 1 | sort -k1,1 -t$'\\t' | cut -f2 -d$'\\t'", "predicted_output": "sort file_name | uniq", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Filnd all directory in root directory with 777 permission and change permision755  with chmod commad .", "reference_output": "find / -type d  -perm 777 -print -exec chmod 755 {} \\;", "predicted_output": "find / -type d -perm 777 -exec chmod 755 {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find file names *blast* in specfied directory", "reference_output": "find /usr/local -name \"*blast*\"", "predicted_output": "find /path/to/directory -name \"*blast*\"", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all executables under /path directory", "reference_output": "find /path -perm /ugo+x", "predicted_output": "find /path -type f -perm -111", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Pipe 3 newlines to sshe-keygen, answering prompts automatically.", "reference_output": "echo -e \"\\n\\n\\n\" | ssh-keygen -t rsa", "predicted_output": "ssh-keygen -t rsa -N '' -f /tmp/id_rsa", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Force tty allocation and execute \"./script.py\" on host \"foo\"", "reference_output": "ssh -tt foo ./script.py", "predicted_output": "ssh -t foo ./script.py", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "List the directory paths of all *.ext (case insensitive) files under /path directory", "reference_output": "find /path -type f -iname \"*.ext\" -printf \"%h\\n\"", "predicted_output": "find /path -iname \"*.ext\" -printf \"%h\\n\" | sort -u", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Display the number of lines in all regular files under current directory tree and also show the total count", "reference_output": "find . -type f -exec wc -l {} +", "predicted_output": "find . -type f -print0 | xargs -0 cat | wc -l", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "List all zero-length files", "reference_output": "find . -empty -exec ls {} \\;", "predicted_output": "find . -type f -size 0", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "delete all files that have the extension \"bam\" in current directory", "reference_output": "find . -name \"*.bam\" | xargs rm", "predicted_output": "find . -name \"*.bam\" -exec rm {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all regular files starting from level 3 of directory tree ~/container and move them one level up", "reference_output": "find ~/container -mindepth 3 -type f -execdir mv \"{}\" ./.. \\;", "predicted_output": "find ~/container -mindepth 3 -maxdepth 3 -type f -exec mv {} ~/container/ \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Recursively finds strings like \"texthere\"  in all \"*.txt\" files of a current folder.", "reference_output": "grep -r --include \"*.txt\" texthere .", "predicted_output": "find . -name \"*.txt\" -exec grep -H \"texthere\" {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Print all file/directory names without white space safety under the /proc directory", "reference_output": "find /proc | xargs", "predicted_output": "find /proc -printf '%f\\n'", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all the files whose name is FindCommandExamples.txt and contains both capital and small letters in / directory", "reference_output": "find  / -iname findcommandexamples.txt", "predicted_output": "find / -iname FindCommandExamples.txt", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "find all the word press configuration php files in the folder /var/www and do not search beyond two levels", "reference_output": "find /var/www/ -name wp-config.php -maxdepth 2", "predicted_output": "find /var/www -maxdepth 2 -name wp-config.php", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all files with 644 permission and change the permission to 664", "reference_output": "find . -type f -perm 644 -exec chmod 664 {} \\;", "predicted_output": "find / -type f -perm 644 -exec chmod 664 {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "create a zip of all the files in the current folder which are bigger than 100Kb and do not go more than 2 levels during search", "reference_output": "find . -maxdepth 2 -size +100000 -exec bzip2 {} \\;", "predicted_output": "find . -maxdepth 2 -size +100k -print0 | xargs -0 tar -czvf archive.tar.gz", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all regular files with '.jpg'  extension, sort them by name, print the output  and also save the list to file 'file_list.txt'", "reference_output": "find . -type f|grep -i \"\\.jpg$\" |sort| tee file_list.txt", "predicted_output": "find . -type f -name \"*.jpg\" -print | sort > file_list.txt", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all regular files in the current directory tree that have been modified within the last 10 minutes", "reference_output": "find . \u2013type f -mmin -10", "predicted_output": "find . -type f -mmin -10", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Search for .pdf files", "reference_output": "find / -name '*.pdf'", "predicted_output": "find . -name \"*.pdf\"", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "find all the files in the current directory which are bigger than 1000MB", "reference_output": "find . -size +1000M", "predicted_output": "find . -size +1000M", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "find a.out, *.o and core files under the current directory and sub-directories and delete them.", "reference_output": "find . \\( -name a.out -o -name '*.o' -o -name 'core' \\) -exec rm {} \\;", "predicted_output": "find . -name a.out -o -name '*.o' -o -name core -exec rm -f {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all files/directories named 'Waldo' under 'Books' directory tree that is located in user's home directory", "reference_output": "find ~/Books -name Waldo", "predicted_output": "find ~/Books -name Waldo", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "Find all files/directories under current directory tree whose names start with 'test' followed by two digits and end with '.txt' extension", "reference_output": "find . -regextype sed -regex \"./test[0-9]\\{2\\}.txt\"", "predicted_output": "find . -name 'test[0-9][0-9].txt'", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Print the day at 1 day ago in 2 months from now", "reference_output": "date -d \"$(date -d \"2 months\" +%Y-%m-1) -1 day\" +%a", "predicted_output": "date -d \"2 months ago\" +%d", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "recursively copy files by file extension, preserving directory structure", "reference_output": "find -type f -name \\*.txt -exec install -D {} /dest/path/{} \\;", "predicted_output": "find . -name \"*.txt\" -print0 | xargs -0 -I {} cp {} /path/to/destination", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Search for files/directories which are writable by both their owner and their group", "reference_output": "find . -perm -g+w,u+w", "predicted_output": "find / -perm -220", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "show all files in /usr/tom and display only files ending with \".pl\" or \".pm\"", "reference_output": "find /usr/tom | egrep '*.pl| *.pm'", "predicted_output": "find /usr/tom -type f -name \"*.pl\" -o -name \"*.pm\"", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "find all the files ending with \"~\" in current folder and move them to temp folder", "reference_output": "find -name '*~' -print0 | xargs -0 -I _ mv _ /tmp/", "predicted_output": "find . -name \"*~\" -exec mv {} temp/ \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Finds recursion-related options of a 'grep' utility.", "reference_output": "grep --help |grep recursive", "predicted_output": "grep --help | grep -i recursion", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Delete every second line from output of \"seq 10\"", "reference_output": "seq 10 | sed '0~2d'", "predicted_output": "seq 10 | sed 'N;D'", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "change cgi files to mode 755 under htdocs or cgi-bin directories", "reference_output": "find htdocs cgi-bin -name \"*.cgi\" -type f -exec chmod 755 {} \\;", "predicted_output": "find /htdocs /cgi-bin -name \"*.cgi\" -exec chmod 755 {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Read a line of standard input into variable \"input_cmd\" with prompt \"command : \"", "reference_output": "read -p \"command : \" input_cmd", "predicted_output": "read -p \"command : \" input_cmd", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "Modify and rewrite 'file' replacing all instances of \"foo\" with \"bar\"", "reference_output": "sed -i 's/foo/bar/g' file", "predicted_output": "sed -i 's/foo/bar/g' file", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "Look for files with wide open permissions", "reference_output": "find . -type f  -perm 777 -exec ls -l {} \\;", "predicted_output": "find / -perm -777", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Remove all \"core\" files that were last changed more than 4 days ago from the current directory tree", "reference_output": "find . -name core -ctime +4 -exec /bin/rm -f {} \\;", "predicted_output": "find . -name core -mtime +4 -exec rm -f {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Print '\"HTTP/1.1 200 OK', two new lines and the current date", "reference_output": "echo -e \"HTTP/1.1 200 OK\\n\\n $\"", "predicted_output": "echo -e \"HTTP/1.1 200 OK\\n\\n$(date)\"", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "list all javascipts file expect files under proc folder", "reference_output": "find . -type d -name proc -prune -o -name '*.js'", "predicted_output": "find / -name \"*.js\" -not -path \"/proc/*\"", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all files/directories under current directory tree whose paths start with './sr' and end with 'sc'", "reference_output": "find . -path './sr*sc'", "predicted_output": "find . -path './sr*' -prune -o -path './sc*' -prune -o -print", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "display all normal/regular files in current directory", "reference_output": "find . -type f -print0", "predicted_output": "find . -type f", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "create a symbolic link with absolute path \"/cygdrive/c/Users/Mic/mypics\" to file \"/cygdrive/c/Users/Mic/Desktop/PENDING - Pics/\"", "reference_output": "ln -sf '/cygdrive/c/Users/Mic/Desktop/PENDING - Pics/' /cygdrive/c/Users/Mic/mypics", "predicted_output": "ln -s /cygdrive/c/Users/Mic/mypics /cygdrive/c/Users/Mic/Desktop/PENDING\\ -\\ Pics/", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Change permissions to 0755 for all directories in the /path directory tree", "reference_output": "find /path -type d -exec chmod 0755 \"{}\" \\;", "predicted_output": "find /path -type d -exec chmod 0755 {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "List all available commands in Mac OS", "reference_output": "echo $PATH | tr ':' '\\n' | xargs -I {} find {} -maxdepth 1 -type f -perm '++x'", "predicted_output": "compgen -c", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all files/directories under current directory tree that belong to the group 'compta'", "reference_output": "find -group compta", "predicted_output": "find . -group compta", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "search for a word in all the php files in the current folder and display the count of all matching lines.", "reference_output": "find . -name \\*.php -type f -exec grep -Hn '$test' {} \\; | wc -l", "predicted_output": "find . -name \"*.php\" -exec grep -o \"word\" {} \\; | wc -l", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "run command \"set -a; . /path/to/nullmailer-vars; set +a; /usr/sbin/logcheck\" with a bash as user root", "reference_output": "su -s /bin/bash -c \"set -a; \\                     . /path/to/nullmailer-vars; \\                     set +a; \\                     /usr/sbin/logcheck\" logcheck", "predicted_output": "sudo bash -c 'set -a; . /path/to/nullmailer-vars; set +a; /usr/sbin/logcheck'", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Print the $N'th line from file by replacing commas (',') with newlines", "reference_output": "head -$N file | tail -1 | tr ',' '\\n'", "predicted_output": "sed -n \"${N}p\" file | tr ',' '\\n'", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Replace \",,\" with \", ,\" twice in \"data.csv\" and display the \",\" delimited result as a table", "reference_output": "sed 's/,,/, ,/g;s/,,/, ,/g' data.csv | column -s, -t", "predicted_output": "sed 's/,/,/2' data.csv | column -t", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all files/directories with 777 permission under current directory tree", "reference_output": "find . -perm 777 -print", "predicted_output": "find . -perm 777", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "list all system calls during process of symbolic link creation process on  \"/tmp/output.txt\" file", "reference_output": "strace -o /tmp/output.txt ln -s -f .bash_aliases test", "predicted_output": "strace -e trace=file -o /tmp/output.txt ln /tmp/input.txt /tmp/output.txt", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all directories under $d directory and set read-write-execute permission for owner and group and no permission for other for those directories", "reference_output": "find $d -type d -exec chmod ug=rwx,o= '{}' \\;", "predicted_output": "find $d -type d -exec chmod 750 {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "display all the text files in a folder", "reference_output": "find $1 -type f -name '*'$n'.txt'", "predicted_output": "find . -type f -name \"*.txt\"", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "search  in current directory downwards all files whose status has changed more then 7  days ago", "reference_output": "find .  -ctime +7 -print", "predicted_output": "find . -ctime +7", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Prints a random number between 2000 and 65000", "reference_output": "seq 2000 65000 | sort -R | head -n 1", "predicted_output": "shuf -i 2000-65000 -n 1", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all files beneath the current directory that end with the extension .java and contain the characters String ignoring case.  Print the name of the file where a match is found.", "reference_output": "find . -type f -name \"*.java\" -exec grep -il string {} \\;", "predicted_output": "find . -name \"*.java\" -exec grep -il \"String\" {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Compress every file in the current directory tree that matches \"*cache.html\" and keep the original file", "reference_output": "find . -type f -name \"*cache.html\" -exec gzip -k {} \\;", "predicted_output": "find . -name \"*cache.html\" -exec gzip -c {} \\; > {}.gz", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Count non-blank lines in a file 'foo.c'", "reference_output": "cat foo.c | sed '/^\\s*$/d' | wc -l", "predicted_output": "grep -c . foo.c", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Append \"<br/>\" to the end of each line in \"1\\n2\\n3\"", "reference_output": "echo -e \"1\\n2\\n3\" | sed 's/.*$/&<br\\/>/'", "predicted_output": "echo -e \"1\\n2\\n3\" | sed 's/$/<br\\/>/'", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Assign the alias rm1g to a find command that removes any .tar file larger than a gigabyte.", "reference_output": "alias rm1g=\"find / -type f -name *.tar -size +1G -exec rm -i {} \\;\"", "predicted_output": "alias rm1g='find . -type f -size +1G -exec rm {} \\;'", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Remove all files with names like \"vmware-*.log\" from the current directory tree", "reference_output": "find . -name vmware-*.log | xargs rm", "predicted_output": "find . -name \"vmware-*.log\" -exec rm -f {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Prints path to folder that contains file \"/path/to/vm.vmwarevm/vm.vmx\".", "reference_output": "echo /path/to/vm.vmwarevm/vm.vmx | xargs dirname", "predicted_output": "dirname $(readlink -f /path/to/vm.vmwarevm/vm.vmx)", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Search /path/to/your/directory for *.avi and *.flv files", "reference_output": "find /path/to/your/directory -regex '.*\\.\\'", "predicted_output": "find /path/to/your/directory -iname \"*.avi\" -o -iname \"*.flv\"", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Check if the directory tree whose name is given as variable $somedir contains no regular files", "reference_output": "find \"$somedir\" -type f -exec echo Found unexpected file {} \\;", "predicted_output": "find $somedir -type f -print -quit | grep -q .", "exact_match": false, "command_only": false, "syntax_valid": null}
{"instruction": "set alias \"current\" for command 'cd $'", "reference_output": "alias current='cd $'", "predicted_output": "alias current='cd $'", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "Print only group names from /etc/group.", "reference_output": "cut -d: -f1 /etc/group", "predicted_output": "cut -d: -f1 /etc/group", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "find all files and directories under the current directory and display the inode of each one, using the stat command on FreeBSD/OSX", "reference_output": "find . -print0 | xargs -0 stat -f '%i '", "predicted_output": "find . -exec stat -f %i {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Print fourth column of space-separated data from text file text.txt.", "reference_output": "cat text.txt | cut -d \" \" -f 4", "predicted_output": "cut -d' ' -f4 text.txt", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Run 'join' on file1 and file2, using a literal tab character as field separator.", "reference_output": "join -t $'\\t' file1 file2", "predicted_output": "join -t $'\\t' file1 file2", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "List all files under current directory with their sizes and paths", "reference_output": "find . -type f -printf '%s %p\\n'", "predicted_output": "find . -type f -exec ls -lh {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all user files larger than 5MB", "reference_output": "find / -size  +5000000c 2> /dev/null", "predicted_output": "find / -user $USER -size +5M", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Recursively prints all files in a current folders, and searches \"stringYouWannaFind\" in file content ignoring case differences, and preceding found string with its number in file.", "reference_output": "find ./ -type f -print -exec grep -n -i \"stringYouWannaFind\" {} \\;", "predicted_output": "find . -type f -exec grep -i -n \"stringYouWannaFind\" {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "find all the text files in the current folder and do not  search in the sub directories", "reference_output": "find -maxdepth 1 -iname \"*.txt\"", "predicted_output": "find . -maxdepth 1 -type f -name \"*.txt\"", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Save the canonical path of \"$dir/$file\" in variable \"path\"", "reference_output": "path=`readlink --canonicalize \"$dir/$file\"`", "predicted_output": "path=$(readlink -f \"$dir/$file\")", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Copy \"/home/username/path/on/server/\" to \"username@your.ip.address.here:/Users/username/path/on/machine/\" and convert encoding from UTF-8 to UTF-8-MAC", "reference_output": "rsync --iconv=UTF-8,UTF-8-MAC /home/username/path/on/server/ 'username@your.ip.address.here:/Users/username/path/on/machine/'", "predicted_output": "rsync -av --from0 --iconv=UTF-8,UTF-8-MAC /home/username/path/on/server/ username@your.ip.address.here:/Users/username/path/on/machine/", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find every file/directory under the directory /home owned by the user joe", "reference_output": "find /home -user joe", "predicted_output": "find /home -user joe", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "display all the directories in the folder /path/to/dest except tmp directory", "reference_output": "find /path/to/dest -type d \\ -print", "predicted_output": "find /path/to/dest -type d -not -name tmp", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Runs `file' on every file in or below the current directory.", "reference_output": "find . -type f -exec file '{}' \\;", "predicted_output": "find . -type f -exec file {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find recursively all regular files changed within the last 5 minutes starting from directory b", "reference_output": "find b -type f -cmin -5", "predicted_output": "find b -type f -cmin -5", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "Print numbers from 1 to 30 with 0 padding to a width of 2", "reference_output": "seq -f \"%02g\" 30", "predicted_output": "seq -w 1 30", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Remove Mac OS X Desktop Services Store files", "reference_output": "find . -name \".DS_Store\" -exec rm {} \\;", "predicted_output": "find / -name '.DS_Store' -depth -exec rm -f {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Finds users with X session in system and puts the result in USERS variable.", "reference_output": "USERS=$(w | awk '/\\/X/ {print $1}')", "predicted_output": "USERS=$(who | grep 'X' | awk '{print $1}')", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "display all normal / regular files in current folder in reverse order", "reference_output": "find . -type f | tac", "predicted_output": "find . -type f -print0 | xargs -0 ls -l | sort -r", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "login as user YOUR_USER", "reference_output": "su - YOUR_USER", "predicted_output": "ssh YOUR_USER", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Remove all files with the .c extension in the current directory tree", "reference_output": "find . -name \"*.c\" -print0 | xargs -0 rm -rf", "predicted_output": "find . -name \"*.c\" -exec rm {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "find all instances of a file in the current folder and create a backup of it in the floppy", "reference_output": "find . -name nameoffile -print | cpio -iv > /dev/fd0", "predicted_output": "find . -name \"filename\" -exec cp {} /floppy/{} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Save the md5 sum hash of \"$my_iso_file\" to variable \"md5\"", "reference_output": "md5=$", "predicted_output": "md5=$(md5sum \"$my_iso_file\" | cut -d' ' -f1)", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Calculate the md5 sum of the file \"filename\" and print only the hash", "reference_output": "md5sum filename |cut -f 1 -d \" \"", "predicted_output": "md5sum filename | cut -d' ' -f1", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find files that are writable by both the \u201cother\u201d and the group under the plsql directory", "reference_output": "find plsql -type f  -perm -220 -exec ls -l {} \\; 2>/dev/null", "predicted_output": "find plsql -perm -o+w -perm -g+w", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Reverse the text in $input by taking each 4 characters as each units and save the result in variable 'output'", "reference_output": "output=$", "predicted_output": "output=`echo $input | sed 's/.\\{4\\}/& /g' | rev | sed 's/ //g'`", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Takes folder name of file $0, changes backslashes to forward ones and saves result in $basedir variable.", "reference_output": "basedir=$(dirname \"$(echo \"$0\" | sed -e 's,\\\\,/,g')\")", "predicted_output": "basedir=$(dirname $0 | sed 's|\\\\|/|g')", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Search the current directory tree for *.conf and *.txt files", "reference_output": "find . -type f \\ -print", "predicted_output": "find . -name \"*.conf\" -o -name \"*.txt\"", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all directories with permissions 777 under and below /var/www/html, and change their permissions to 755", "reference_output": "find /var/www/html -type d -perm 777 -print -exec chmod 755 {} \\;", "predicted_output": "find /var/www/html -type d -perm 777 -exec chmod 755 {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find files with 002 permission in entire file system", "reference_output": "find / -type f -perm -002", "predicted_output": "find / -perm 002", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "find all the files in the current directory which have the inode number 31246 and remove them.", "reference_output": "find . -inum 31246 -exec rm [] ';'", "predicted_output": "find . -inum 31246 -exec rm {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find and print the names of all files found in the current directory and all of its sub-directories.", "reference_output": "find . -print", "predicted_output": "find . -print", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "Creates temporary file and saves path to it in a 'tmpfile' variable.", "reference_output": "tmpfile=$(mktemp)", "predicted_output": "tmpfile=$(mktemp)", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "Archive \"/home/abc/*\" to \"/mnt/windowsabc\" with human readable output", "reference_output": "rsync -avh /home/abc/* /mnt/windowsabc", "predicted_output": "rsync -ahv /home/abc/* /mnt/windowsabc", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Print the names of all files and directories in the current directory tree", "reference_output": "find .", "predicted_output": "find . -print", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "sort and display top 11 files along with the last access date for all the files in the file system", "reference_output": "find / -type f -printf \"\\n%AD %AT %p\" | head -n 11 | sort -k1.8n -k1.1nr -k1", "predicted_output": "find / -printf \"%T+ %p\\n\" | sort | tail -n 11", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all flies under current directory excluding *.png files and print the file paths  that match the case insensitive regex 'foo=' in their contents", "reference_output": "find . -not -name '*.png' -o -type f -print | xargs grep -icl \"foo=\"", "predicted_output": "find . -type f -not -name '*.png' -exec grep -i 'foo=' {} +", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all *.* directories under /home/feeds/data directory", "reference_output": "find /home/feeds/data -type d \\ -prune -o -name '*.*' -print", "predicted_output": "find /home/feeds/data -type d -name \"*.*\"", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "sleep for 10 seconds", "reference_output": "sleep `10`", "predicted_output": "sleep 10", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Searches the manual pages with descriptions in section 3, that name begins with lowercase letter.", "reference_output": "apropos -s 3 . | grep ^[a-z]", "predicted_output": "apropos -s 3 -i -w -d", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find files in the /var/log folder which were modified modified 2 weeks ago", "reference_output": "find /var/log/ -mtime +7 -mtime -8", "predicted_output": "find /var/log -mtime +14", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "search for all regular/normal files in the current folder and display the number of lines in the file", "reference_output": "find . -type f -print | xargs -L1 wc -l", "predicted_output": "find . -type f -exec wc -l {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "search for the file, filename.txt in the current folder", "reference_output": "find . -iname filename.txt", "predicted_output": "find . -name filename.txt", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "display all the files in the current folder excluding the directory aa", "reference_output": "find . -type d ! -name aa", "predicted_output": "find . -type f -not -path \"./aa/*\"", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Request IP address of 'myip.opendns.com' from name server 'resolver1.opendns.com'", "reference_output": "dig +short myip.opendns.com @resolver1.opendns.com", "predicted_output": "nslookup myip.opendns.com resolver1.opendns.com | grep Address | awk '{print $2}'", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Print the size for every *.ogg file found under the home directory", "reference_output": "find $HOME -name '*.ogg' -type f -exec du -h '{}' \\;", "predicted_output": "find ~ -name \"*.ogg\" -exec ls -lh {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find file `Chapter1' on the system", "reference_output": "find / -name Chapter1 -type f -print", "predicted_output": "find / -name Chapter1", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Delete files containing whitespaces without recursion", "reference_output": "find . -name '*[+{;\"\\\\=?~<>&*|$ ]*' -maxdepth 0 -exec rm -f '{}' \\;", "predicted_output": "find . -name \"* *\" -print0 | xargs -0 rm", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "display all the \".c\" files which have been modified in the last 10 minutes", "reference_output": "find /home/david -amin -10 -name '*.c'", "predicted_output": "find . -name \"*.c\" -mmin -10", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all directories in the /data1/realtime directory tree that were last modified more than 5 minutes ago but less than 60 minutes ago", "reference_output": "find /data1/realtime -mmin -60 -mmin +5 -type d", "predicted_output": "find /data1/realtime -type d -mmin +5 -mmin -60", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Create a symbolic link named the basename of \"$file\" to \"$file\"", "reference_output": "ln -s $file `basename $file`", "predicted_output": "ln -s \"$file\" \"$file\"", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Format tab separated fields in \"FILE\" as a table", "reference_output": "column -t -s $'\\t' FILE", "predicted_output": "cat FILE | column -t", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Decompress \"path/to/test/file.gz\" to standard output and save all lines matching \"my regex\" to files with a 1000000 line limit", "reference_output": "gzip -dc path/to/test/file.gz | grep -P --regexp='my regex' | split -l1000000", "predicted_output": "zcat path/to/test/file.gz | grep -C 0 my\\ regex | split -l 1000000 - path/to/output/", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "split content of the file file.txt started from second line into pieces per 4 lines named as split_NNN", "reference_output": "tail -n +2 file.txt | split -l 4 - split_", "predicted_output": "tail -n +2 file.txt | split -l 4 - split_", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "sort each file in the bills directory, leaving the output in that file name with .sorted appended", "reference_output": "find bills -type f | xargs -I XX sort -o XX.sorted XX", "predicted_output": "find bills -type f -exec sort {} \\; -exec mv {} {}.sorted \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "find all regular/normal files in current folder and display the filename and size", "reference_output": "find $/* -type f -exec stat -c \"f%15s %n\" {} +", "predicted_output": "find . -type f -exec ls -lh {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Calculate the sum of all the numbers from 1 to 10", "reference_output": "seq 10|jq -s add", "predicted_output": "seq 1 10 | paste -sd+ | bc", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all files in the current directory tree and count them", "reference_output": "find | wc -l", "predicted_output": "find . -type f | wc -l", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find the largest original \".gz\" file in the current directory tree", "reference_output": "find . -name '*.gz' | xargs gzip -l | tail -n +2 | head -n -1 | sort -k 2 | tail -n 1 | awk '{print $NF}'", "predicted_output": "find . -name '*.gz' -printf \"%s %p\\n\" | sort -nr | head -n 1", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Set the timestamp of B to the same one as A", "reference_output": "touch -r A B", "predicted_output": "touch -r A B", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "Remove all files in the current directory tree that have the name \"abc.xxx\"", "reference_output": "find . -name abc.xxx -exec rm {} \\;", "predicted_output": "find . -name abc.xxx -exec rm {} \\;", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "Remove all *.doc files from the current directory tree", "reference_output": "find . -name '*.doc' -exec rm \"{}\" \\;", "predicted_output": "find . -name \"*.doc\" -exec rm {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "List the files from the current directory tree that contain lines approximately matching regular expression '^Subject:.*unique subject'", "reference_output": "find . -type f -print | xargs agrep -2 -il '^Subject:.*unique subject'", "predicted_output": "find . -type f -exec grep -l '^Subject:.*unique subject' {} \\;", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Print a listing of the /usr/local/etc/rc.d directory tree", "reference_output": "find /usr/local/etc/rc.d -type f | awk -F/ '{print $NF}'", "predicted_output": "find /usr/local/etc/rc.d -print", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all the regular files under '/your/dir' directory tree which are bigger than 5 MB and display them in decreasing order of their sizes", "reference_output": "find /your/dir -type f -size +5M -exec du -h '{}' + | sort -hr", "predicted_output": "find /your/dir -type f -size +5M -exec ls -lh {} \\; | sort -rh", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "display all the php files in the entire file system", "reference_output": "find / -name \"*.php\"", "predicted_output": "find / -name \"*.php\"", "exact_match": true, "command_only": true, "syntax_valid": null}
{"instruction": "Look for SGID files and directories", "reference_output": "find / -perm /g=s", "predicted_output": "find / -perm -g+s -print", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Find all \"G*.html\" files modified more than 7 days ago in the current directory tree and pass them as arguments to script /path/to/script_7zipi", "reference_output": "find . -mtime +7 -name \"G*.html\" -execdir  /path/to/script_7zipi {} +", "predicted_output": "find . -name \"G*.html\" -mtime +7 -print0 | xargs -0 /path/to/script_7zipi", "exact_match": false, "command_only": true, "syntax_valid": null}
{"instruction": "Creates temporary file with name formatted like '.script.XXXXXX' in '/tmp/' folder and saves path to it in 'script1' variable.", "reference_output": "script1=`mktemp /tmp/.script.XXXXXX`;", "predicted_output": "script1=$(mktemp /tmp/script.XXXXXX)", "exact_match": false, "command_only": true, "syntax_valid": null}
